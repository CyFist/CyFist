<!DOCTYPE html>
<html>
  
  <head>
    <title>Flight/Weather Radar</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script type="module" src="https://github.com/abdulk1/Leaflet.RotatedMarker/blob/main/src/rotatedMarker.js"></script>
    
    <style>
    .my-control {
      background-color: #8f8e8e;
      padding: 0px;
    }
    
      html,
      body {
        height: 100%;
        margin: 0;
      }

      li {
        list-style: none;
        display: inline-block;
      }

      #map {
        width: 100%;
        height: 500px;
      }
      
      .aircraft-icon {
        transform-origin: center;
      }
      input {
        background-color: #8f8e8e;
        border-radius: 4px;
        color: #eeeeee;
        text-align: center;
        font-size: 16px;
        cursor: pointer;
        margin: 0px;
      }
      input:hover {
      background-color: #cab278;
    }
      .leaflet-radar {
       
        /* from leaflet-control-layers */
        border-radius: 5px;
        background: #fff;
        border: 2px solid rgba(0, 0, 0, 0.2);
        background-clip: padding-box;
        
        padding: 5px;
        height: 100%;
    }
    
    .leaflet-radar .leaflet-radar-timestamp {
            text-align: center;
    }
    </style>
  </head>
  
  <body>

    <div id='map'></div>
    <script>
        L.Control.WxControl = L.Control.extend({
            position: 'topright',
            
          onAdd: function(map) {
            var el = L.DomUtil.create('div', 'leaflet-bar my-control');
            
            el.innerHTML =
                '<input type="button" onmouseover="stop(); showFrame(animationPosition - 1); return;" value="&lt;" />' +
                '<input type="button" onclick="playStop();" value="Play / Stop" />' +
                '<input type="button" onmouseover="stop(); showFrame(animationPosition + 1); return;" value="&gt;" />'+
                '<div id="timestamp" style="text-align:center"></div>';
        
            return el;
          },
        
          onRemove: function(map) {
              WxControl.remove()
            // Nothing to do here
          }
        });
        
        L.control.WxControl = function(opts) {
          return new L.Control.WxControl(opts);
        }
    </script>
    <script>
            L.Control.Radar = L.Control.extend({
    
        NEXRAD_URL: `https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi`,
        NEXRAD_LAYER: `nexrad-n0q-900913`,
    
        isPaused: false,
        timeLayerIndex: 0,
        timeLayers: [],
    
        options: {
            position: `topright`,
            opacity: 0.575,
            zIndex: 200,
            transitionMs: 750,
            playHTML: `&#9658;`,
            pauseHTML: `&#9616;`,
        },
    
        onRemove: function () {
            L.DomUtil.remove(this.container);
        },
    
        onAdd: function (map) {
            this.map = map;
    
            // setup control container
            this.container = L.DomUtil.create(`div`, "leaflet-radar");
    
            L.DomEvent.disableClickPropagation(this.container);
            L.DomEvent.on(this.container, `control_container`, function (e) {
                L.DomEvent.stopPropagation(e);
            });
            L.DomEvent.disableScrollPropagation(this.container);
    
            // add control elements within container
            checkbox_div = L.DomUtil.create(
                `div`,
                `leaflet-radar-toggle`,
                this.container
            );
    
            let slider_div = L.DomUtil.create(
                `div`,
                `leaflet-radar-slider`,
                this.container
            );
    
            this.slider = document.createElement(`input`);
            this.slider.id = `leaflet-radar-slider`;
            this.slider.type = `range`;
            this.slider.min = 0;
    
            slider_div.appendChild(this.slider);
    
            this.timestamp_div = L.DomUtil.create(
                `div`,
                `leaflet-radar-timestamp`,
                this.container
            );
            
            this.setDisabled(false);
    
            this.timeLayers = this.generateLayers();
            this.addLayers(this.timeLayers);
    
            this.slider.max = `${this.timeLayers.length - 1}`;
    
            this.timeLayerIndex = 0;
    
            this.isPaused = false;
    
            this.slider.oninput = () => {
    
                this.hideLayerByIndex(this.timeLayerIndex);
                this.timeLayerIndex = +this.slider.value;
                this.showLayerByIndex(this.timeLayerIndex);
    
                this.isPaused = true;
            };
    
            this.setTransitionTimer();
            
            return this.container;
        },
    
        hideLayerByIndex: function (index) {
            this.timeLayers[index].tileLayer.setOpacity(0);
            this.timestamp_div.innerHTML = ``;
        },
    
        showLayerByIndex: function (index) {
            this.timeLayers[index].tileLayer.setOpacity(
                this.options.opacity
            );
            this.timestamp_div.innerHTML = this.timeLayers[index].timestamp;
        },
    
    
        setTransitionTimer: function () {
            setTimeout(() => {
                if (this.isPaused) {
                    return;
                }
    
                this.timeLayers.forEach(timeLayer => {
                    timeLayer.tileLayer.setOpacity(0);
                    timeLayer.tileLayer.addTo(this.map);
                });
    
                this.hideLayerByIndex(this.timeLayerIndex);
                this.incrementLayerIndex();
                this.showLayerByIndex(this.timeLayerIndex);

                this.slider.value = `${this.timeLayerIndex}`;

                this.setTransitionTimer();
                
            }, this.options.transitionMs);
        },
    
        incrementLayerIndex: function () {
            this.timeLayerIndex++;
            if (this.timeLayerIndex > this.timeLayers.length - 1) {
                this.timeLayerIndex = 0;
            }
        },
    
        addLayers: function () {
            this.timeLayers.forEach(timeLayer => {
                timeLayer.tileLayer.setOpacity(0);
                timeLayer.tileLayer.addTo(this.map);
            });
        },
    
        removeLayers: function () {
            this.timeLayers.forEach(timeLayer =>
                timeLayer.tileLayer.removeFrom(this.map)
            );
            this.timeLayers = [];
            this.timeLayerIndex = 0;
        },
    
        generateLayers: function () {
            let timeLayers = [];
    
            const TOTAL_INTERVALS = 10;
            const INTERVAL_LENGTH_HRS = 5;
    
            const currentTime = new Date();
    
            for (let i = 0; i <= TOTAL_INTERVALS; i++) {
    
                const timeDiffMins =
                    TOTAL_INTERVALS * INTERVAL_LENGTH_HRS -
                    INTERVAL_LENGTH_HRS * i;
    
                const suffix = (function(time) {  
                    switch(time) {
                        case 0:
                            return '';
                        case 5:
                            return '-m05m';
                        default:
                            return '-m' + time + 'm';
                    }
                    })(timeDiffMins);
    
                const layerRequest = this.NEXRAD_LAYER + suffix;
    
                const layer = L.tileLayer.wms(this.NEXRAD_URL, {
                    layers: layerRequest,
                    format: `image/png`,
                    transparent: true,
                    opacity: this.options.opacity,
                    zIndex: this.options.zIndex
                });
    
                const timeString = new Date(
                    currentTime.valueOf() - timeDiffMins * 60 * 1000
                ).toLocaleTimeString();
                timeLayers.push({
                    timestamp: `${timeString} (-${timeDiffMins} min)`,
                    tileLayer: layer
                });
            }
            return timeLayers;
        }
    });
    
    L.control.radar = function (options) {
        return new L.Control.Radar(options);
    };
        
    </script>
    <script>
      var aircraftLayer = L.layerGroup();
      var weather = L.layerGroup();
      var mbAttr = '&copy;  <a href = "https://www.openstreetmap.org/copyright">OpenStreetMap</a> ',
      mbUrl = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';
      var grayscale = L.tileLayer(mbUrl, {
          id: 'mapbox/light-v9',
          tileSize: 512,
          zoomOffset: -1,
          attribution: mbAttr
        }),
        darkmap = L.tileLayer(mbUrl, {
          id: 'mapbox/dark-v10',
          tileSize: 512,
          zoomOffset: -1,
          attribution: mbAttr
        }),
        streets = L.tileLayer(mbUrl, {
          id: 'mapbox/streets-v11',
          tileSize: 512,
          zoomOffset: -1,
          attribution: mbAttr
        }),
        openaip = L.tileLayer('http://{s}.tile.maps.openaip.net/geowebcache/service/tms/1.0.0/openaip_basemap@EPSG%3A900913@png/{z}/{x}/{y}.{ext}', {
	  attribution: '<a href="https://www.openaip.net/">openAIP</a>',
	  ext: 'png',
	  minZoom: 4,
	  maxZoom: 14,
	  tms: true,
	  detectRetina: true,
	  subdomains: '12'
        });
      var map = L.map('map', {
        center: [-31.6691429752277, 116.014641735941],
        zoom: 10,
        layers: [grayscale, openaip, aircraftLayer, weather]
      });
      var baseLayers = {
        "Dark Map": darkmap,
        "Light Map": grayscale,
        "Streets": streets
      };
      var overlays = {
        "AirSpace": openaip,
        "Air Activities": aircraftLayer,
        "Weather": weather
      };
      L.control.layers(baseLayers, overlays).addTo(map);
      
      var WxCtrl;
      
      Wxctrl = L.control.radar({}).addTo(map);
      
      L.control.scale(
        {metric: false}).addTo(map)
        
        map.on('overlayadd', function(eo) {
            if (eo.name === 'Weather'){
                Wxctrl = L.control.radar({}).addTo(map);
            }
            });
        map.on('overlayremove', function(eo) {
            if (eo.name === 'Weather'){
                map.removeControl(Wxctrl);
            }
            });
        
      // Plot Aircraft
      const apiURL = "https://opensky-network.org/api/"
      const endpoint = "states/all"
      const params = "lamin=-32.5468&lomin=114.6093&lamax=-30.1451&lomax=116.7187"
      const api_url = apiURL + endpoint + "?" + params;
      
      function update_position() {$(document).ready(function() {
        $.get(api_url, function(data, status) {
            aircraftLayer.clearLayers()
          var states = (data.states);
          for (var i in states) {
            var state = states[i];
            var icao24 = state[0],
                callsign = state[1],
                origincountry = state[2],
                timeposition = state[3],
                lastcontact = state[4],
                longitude = state[5],
                latitude = state[6],
                baroaltitude = state[7],
                onground = state[8],
                velocity = state[9],
                truetrack = state[10],
                verticalrate = state[11],
                sensors = state[12],
                geoaltitude = state[13],
                squawk = state[14],
                spi = state[15],
                positionsource = state[16];
            var latlng = L.latLng(state[6], state[5])
                
                var iconOptions = {
                    iconUrl: '<i class="fas fa-plane fa-2x"></i>',
                    iconSize: [50, 50]
                 }
                 
                 // Creating a custom icon
                 var myIcon = L.divIcon({
                     className: 'aircraft-icon',
                     html: '<i class="fas fa-plane fa-2x" style="transform:rotate(calc(-90deg + ' + truetrack + 'deg));"></i>'
                 });
                
                marker = L.marker(latlng, {
                  title: callsign,
                  riseOnHover: true,
                  icon: myIcon
                }).bindPopup(callsign).openPopup().addTo(aircraftLayer);
                
            setTimeout(update_position, 500);
            
          }
        })
      });
      }
      
      update_position();
      
      
      /**
       * RainViewer radar animation part
       * @type {number[]}
       */
      var apiData = {};
      var mapFrames = [];
      var lastPastFramePosition = -1;
      var radarLayers = [];
      var optionKind = 'radar'; // can be 'radar' or 'satellite'
      var optionTileSize = 256; // can be 256 or 512.
      var optionColorScheme = 7; // from 0 to 8. Check the https://rainviewer.com/api/color-schemes.html for additional information
      var optionSmoothData = 1; // 0 - not smooth, 1 - smooth
      var optionSnowColors = 0; // 0 - do not show snow colors, 1 - show snow colors
      var animationPosition = 0;
      var animationTimer = false;
      /**
       * Load all the available maps frames from RainViewer AP
       */
      var apiRequest = new XMLHttpRequest();
      function update_Weather() {apiRequest.open("GET", "https://api.rainviewer.com/public/weather-maps.json", true);
      apiRequest.onload = function(e) {
        // store the API response for re-use purposes in memory
        apiData = JSON.parse(apiRequest.response);
        initialize(apiData, optionKind);
      };
      apiRequest.send();
      setTimeout(update_position, 6000)
      }
      
      update_Weather();
      /**
       * Initialize internal data from the API response and options
       */
      function initialize(api, kind) {
        // remove all already added tiled layers
        for (var i in radarLayers) {
          weather.removeLayer(radarLayers[i]);
        }
        mapFrames = [];
        radarLayers = [];
        animationPosition = 0;
        if (!api) {
          return;
        }
        if (kind == 'satellite' && api.satellite && api.satellite.infrared) {
          mapFrames = api.satellite.infrared;
          lastPastFramePosition = api.satellite.infrared.length - 1;
          showFrame(lastPastFramePosition);
        } else if (api.radar && api.radar.past) {
          mapFrames = api.radar.past;
          if (api.radar.nowcast) {
            mapFrames = mapFrames.concat(api.radar.nowcast);
          }
          // show the last "past" frame
          lastPastFramePosition = api.radar.past.length - 1;
          showFrame(lastPastFramePosition);
        }
      }
      /**
       * Animation functions
       * @param path - Path to the XYZ tile
       */
      function addLayer(frame) {
        if (!radarLayers[frame.path]) {
          var colorScheme = optionKind == 'satellite' ? 0 : optionColorScheme;
          var smooth = optionKind == 'satellite' ? 0 : optionSmoothData;
          var snow = optionKind == 'satellite' ? 0 : optionSnowColors;
          radarLayers[frame.path] = new L.TileLayer(apiData.host + frame.path + '/' + optionTileSize + '/{z}/{x}/{y}/' + colorScheme + '/' + smooth + '_' + snow + '.png', {
            tileSize: 256,
            opacity: 0.001,
            zIndex: frame.time
          });
        }
        if (!weather.hasLayer(radarLayers[frame.path])) {
          weather.addLayer(radarLayers[frame.path]);
        }
      }
      /**
       * Display particular frame of animation for the @position
       * If preloadOnly parameter is set to true, the frame layer only adds for the tiles preloading purpose
       * @param position
       * @param preloadOnly
       */
      function changeRadarPosition(position, preloadOnly) {
        while (position >= mapFrames.length) {
          position -= mapFrames.length;
        }
        while (position < 0) {
          position += mapFrames.length;
        }
        var currentFrame = mapFrames[animationPosition];
        var nextFrame = mapFrames[position];
        addLayer(nextFrame);
        if (preloadOnly) {
          return;
        }
        animationPosition = position;
        if (radarLayers[currentFrame.path]) {
          radarLayers[currentFrame.path].setOpacity(0);
        }
        radarLayers[nextFrame.path].setOpacity(0.7);
        var pastOrForecast = nextFrame.time > Date.now() / 1000 ? '+' : '-';
        dateObj = new Date(nextFrame.time * 1000);
        hours = dateObj.getHours();
        minutes = dateObj.getMinutes();
        
        timeString = hours.toString().padStart(2, '0')
                 + minutes.toString().padStart(2, '0')
                + 'H';
        document.getElementById("timestamp").innerHTML =  timeString;
      }
      /**
       * Check avialability and show particular frame position from the timestamps list
       */
      function showFrame(nextPosition) {
        var preloadingDirection = nextPosition - animationPosition > 0 ? 1 : -1;
        changeRadarPosition(nextPosition);
        // preload next next frame (typically, +1 frame)
        // if don't do that, the animation will be blinking at the first loop
        changeRadarPosition(nextPosition + preloadingDirection, true);
      }
      /**
       * Stop the animation
       * Check if the animation timeout is set and clear it.
       */
      function stop() {
        if (animationTimer) {
          clearTimeout(animationTimer);
          animationTimer = false;
          return true;
        }
        return false;
      }

      function play() {
        showFrame(animationPosition + 1)
        // Main animation driver. Run this function every 500 ms
        animationTimer = setTimeout(play, 500);
      }

      function playStop() {
        if (!stop()) {
          play();
        }
      }
      /**
       * Handle arrow keys for navigation between next \ prev frames
       */
      document.onkeydown = function(e) {
        e = e || window.event;
        switch (e.which || e.keyCode) {
          case 37: // left
            stop();
            showFrame(animationPosition - 1);
            break;
          case 39: // right
            stop();
            showFrame(animationPosition + 1);
            break;
          default:
            return; // exit this handler for other keys
        }
        e.preventDefault();
        return false;
      }
    </script>
    
  </body>
</html>
